#!/usr/bin/env python
#
# Ubuntu aarch64 image
#
# Copyright 2019 Linaro
#
# Authors:
#  Robert Foley <robert.foley@linaro.org>
#  Originally based on ubuntu.i386 Fam Zheng <famz@redhat.com>
#
# This code is licensed under the GPL version 2 or later.  See
# the COPYING file in the top-level directory.
#

import os
import sys
import subprocess
import basevm
import time
import traceback

DEFAULT_CONFIG = {
    'cpu'          : "max",
    'machine'      : 'virt',
    'install_cmds' : 'yum install -y docker make git python3 gcc, '\
                     'yum install -y glib2-devel pixman-devel zlib-devel, '\
                     'yum install -y perl-Test-Harness, '\
                     'systemctl enable docker',
    # We limit to 8 since currently the default centos image's kernel
    # will not come up with gic v3, which is required for > 8 cpus.
    'max_cpus'     : 8,
}

class CentosAarch64VM(basevm.BaseVM):
    name = "centos.aarch64"
    arch = "aarch64"
    login_prompt = "localhost login:"
    prompt = '[root@localhost ~]#'
    image_name = "CentOS-8-aarch64-1905-dvd1.iso"
    image_link = "http://mirrors.usc.edu/pub/linux/distributions/centos/8.0.1905/isos/aarch64/"
    image_link += image_name
    BUILD_SCRIPT = """
        set -e;
        cd $(mktemp -d);
        sudo chmod a+r /dev/vdb;
        tar -xf /dev/vdb;
        ./configure {configure_opts};
        make --output-sync {target} -j{jobs} {verbose};
    """
    def wait_boot(self):
        # When we are in this extra debug mode,
        # also show the console during boot.
        self.console_wait(self.login_prompt)

    def set_key_perm(self):
        # Permissions need to be set properly on
        # the files to allow ssh access.
        self.console_wait_send(self.prompt,
                               "/usr/sbin/restorecon -R -v /root/.ssh\n")
        self.console_wait_send(self.prompt,
                "/usr/sbin/restorecon -R -v "\
                "/home/{}/.ssh\n".format(self.GUEST_USER))

    def create_kickstart(self):
        # Start with the template for the kickstart.
        ks_file = "../tests/vm/centos-8-aarch64.ks"
        subprocess.check_call("cp {} ./ks.cfg".format(ks_file), shell=True)       
        # Append the ssh keys to the kickstart file
        # as the post processing phase of installation.
        with open("ks.cfg", "a") as f:
            f.write("%post --log=/root/ks-post.log\n")
            f.write("mkdir -p /root/.ssh\n")
            addkey = 'echo "{}" >> /root/.ssh/authorized_keys\n'
            addkey_cmd = addkey.format(self.ssh_pub_key)
            f.write(addkey_cmd)
            f.write('mkdir -p /home/{}/.ssh\n'.format(self.GUEST_USER))
            addkey = 'echo "{}" >> /home/{}/.ssh/authorized_keys\n'
            addkey_cmd = addkey.format(self.ssh_pub_key, self.GUEST_USER)
            f.write(addkey_cmd)
            f.write("%end\n")
        # Take our kickstart file and create an .iso from it.
        # The .iso will be provided to qemu as we boot
        # from the install dvd.
        # Anaconda will recognize the label "OEMDRV" and will
        # start the automated installation.
        gen_iso_img = 'genisoimage -output ks.iso -volid "OEMDRV" ks.cfg'
        subprocess.check_call(gen_iso_img, shell=True)

    def wait_for_shutdown(self):
        # we add the console_wait() to make it easier
        # to see what is going on here (for debug).
        # The image creation is essentially done,
        # so whether or not the wait is successful we want to
        # wait for qemu to exit (the self.wait()) before we return.
        try:
            self.console_wait("reboot: Power down")
        except Exception as e:
            sys.stderr.write("Exception hit\n")
            if isinstance(e, SystemExit) and e.code == 0:
                return 0
            traceback.print_exc()
        finally:
            self.wait()

    def create_flash_images(self):
        subprocess.check_call(["dd", "if=/dev/zero", "of=flash0.img", "bs=1M", "count=64"])
        # A reliable way to get the QEMU EFI image is via an installed package.
        efi_img = "/usr/share/qemu-efi-aarch64/QEMU_EFI.fd"
        if not os.path.exists(efi_img):
            sys.stderr.write("*** {} is missing\n".format(efi_img))
            sys.stderr.write("*** please install qemu-efi-aarch64 package\n")
            exit(3)
        subprocess.check_call(["dd", "if={}".format(efi_img), "of=flash0.img", "conv=notrunc"])
        subprocess.check_call(["dd", "if=/dev/zero", "of=flash1.img", "bs=1M", "count=64"])

    def build_base_image(self, img):
        # Create an empty image.
        # We will provide this as the install destination.
        qemu_img_create = "qemu-img create {} 50G".format(img)
        subprocess.check_call(qemu_img_create, shell=True)

        # Create our kickstart file to be fed to the installer.
        self.create_kickstart()
        # Boot the install dvd with the params as our ks.iso
        dvd_iso = self._download_with_cache(self.image_link)
        extra_args = "-cdrom ks.iso"
        extra_args += " -drive file={},format=raw,if=none,id=hd1"
        extra_args += " -device scsi-hd,drive=hd1"
        extra_args = extra_args.format(dvd_iso).split(" ")
        self.boot(img, extra_args=extra_args)
        self.console_wait_send("change the selection", "\n")
        # We seem to need to hit esc (chr(27)) twice to abort the
        # media check, which takes a long time.
        # Waiting a bit seems to be more reliable before hitting esc.
        self.console_wait("Checking")
        time.sleep(5)
        self.console_wait_send("Checking", chr(27))
        time.sleep(5)
        self.console_wait_send("Checking", chr(27))
        print("Found Checking")
        self.wait_for_shutdown()
        print("Done with base image build")

    def check_create_base_img(self, img_base, img_dest):
        # We will use the base image if it exists.
        # This helps cut down on install time in case we
        # need to restart image creation,
        # since the base image creation can take a long time.
        if not os.path.exists(img_base):
            print("Generate new base image: {}".format(img_base))
            self.build_base_image(img_base);
        else:
            print("Use existing base image: {}".format(img_base))
        # Save a copy of the base image and copy it to dest.
        # which we will use going forward.
        subprocess.check_call(["cp", img_base, img_dest])

    def boot(self, img, extra_args=None):
        self.create_flash_images()

        default_args = ["-pflash", "flash0.img", "-pflash", "flash1.img"]
        if extra_args:
            extra_args.extend(default_args)
        else:
            extra_args = default_args
        # We always add these performance tweaks
        # because without them, we boot so slowly that we
        # can time out finding the boot efi device.
        if os.geteuid() != 0:
            extra_args.extend(["-accel", "tcg,thread=multi"])
        if '-smp' not in extra_args and \
           '-smp' not in self._config['extra_args'] and \
           '-smp' not in self._args:
            # Only add if not already there to give caller option to change it.
            extra_args.extend(["-smp", "{}".format(self._config['max_cpus'])])
        # We have overridden boot() since aarch64 has additional parameters.
        # Call down to the base class method.
        super(CentosAarch64VM, self).boot(img, extra_args=extra_args)

    def build_image(self, img):
        img_tmp = img + ".tmp"
        self.check_create_base_img(img + ".base", img_tmp)

        # Boot the new image for the first time to finish installation.
        self.boot(img_tmp)
        self.console_init()
        self.console_wait_send(self.login_prompt, "root\n")
        self.console_wait_send("Password:", "{}\n".format(self.ROOT_PASS))

        self.set_key_perm()
        self.console_wait_send(self.prompt, "rpm -q centos-release\n")
        enable_adapter = "sed -i 's/ONBOOT=no/ONBOOT=yes/g'" \
                         " /etc/sysconfig/network-scripts/ifcfg-enp0s1\n"
        self.console_wait_send(self.prompt, enable_adapter)
        self.console_wait_send(self.prompt, "ifup enp0s1\n")
        self.console_wait_send(self.prompt,
                               'echo "qemu  ALL=(ALL) NOPASSWD:ALL" | '\
                               'sudo tee /etc/sudoers.d/qemu\n')
        self.console_wait(self.prompt)

        # Rest of the commands we issue through ssh.
        self.wait_ssh(wait_root=True)

        # If the user chooses *not* to do the second phase,
        # then we will jump right to the graceful shutdown
        if self._config['install_cmds'] != "":
            install_cmds = self._config['install_cmds'].split(',')
            for cmd in install_cmds:
                self.ssh_root(cmd)
        self.ssh_root("poweroff")
        self.wait_for_shutdown()
        os.rename(img_tmp, img)
        print("image creation complete: {}".format(img))
        return 0

if __name__ == "__main__":
    sys.exit(basevm.main(CentosAarch64VM, DEFAULT_CONFIG))
